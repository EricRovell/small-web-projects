# Анимация "Матрица" с помощью Canvas API

Содержание:

1. [Введение](##введение)
2. [Подготовка документа](##подготовка-документа)
    - [Стили](###стили)
3. [Подготовка canvas](##подготовка-canvas)
4. [Параметры](##параметры)
5. [Отрисовка](##отрисовка)
6. [Расширяем набор символов](##расширяем-набор-символов)
7. [Больше контроля](##больше-контроля)

## Подготовка документа

Для начала создадим пустые документы: index.html, style.css и script.js. Начнём с html документа. Используем базовую разметку, соединим в шапке документа внешний документ стилей, а в теле документа в самом конце - внешний скрипт.

Последнее, что нам ещё необходимо: елемент `<canvas>`, который мы расположим до ссылки на скрипт и дадим ему совершенно неоригинальный **id**: *canvas*.

Наш документ должны выглядеть так:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./style.css">
    <title>The Matrix</title>
  </head>
  <body>
    <canvas id="canvas" />
    <script type="module" src="./script.js"></script>
  </body>
</html>
```

На этом всё, теперь перейдём к документу стилей.

---

### Прописываем стили

На самом деле, работы тут крайне мало. При необходимости, можно записать стили непосредственно в html файл.

Необходимо сбросить стили по умолчанию, чтобы полотно заполняло экран полностью. Так же скроем скролл в теле документа.

```css
* {
  padding: 0;
  margin: 0;
  box-sizing: border-box;
}

body {
  overflow: hidden;
}
```
---

## Подготовка canvas

Перейдём к самому интересному. Работать будем в `script.js`.

Для рисования на полотне необходимо получить доступ к контексту. Сделаем это, обратившись к элементу `canvas` по **id**, используя метод `getElementById()`. Он вернёт нам ссылку на элемент. Чтобы не плодить неиспользуемые переменные, сразу же обратимся к методу `getContext("2d")`, чтобы получить констект для рисования на полотне.

```javascript
const context = document
  .getElementById("canvas")
  .getContext("2d");
```

По умолчанию размер холста не впечатляет: 150x300. В данном примере мы будем работать в полноэкранном режиме, поэтому стоит цель заполучить данные по размерам окна и задать новые размеры полотна.

Данные получим из объекта `window.screen`:

```javascript
const width = (context.canvas.width = window.screen.width);
const height = (context.canvas.height = window.screen.height);
```

Таким образом мы убиваем двух зайцев одним выстрелом: сначала устанавливаем размеры полотна по размеру экрана браузера. Затем, полученная величина, как выражение, записывается в переменную.

> Что интересно, ссылка на элемент `canvas` находится внутри объекта контекста, что очень удобно и исключает необходимость в лишней переменной.

Теперь полотно занимает всю область экрана и у нас есть значения `width` и `height`. Они обязательно пригодятся.

---

## Параметры

Заранее выделим параметры в переменные, с помощью которых мы будем контроллировать анимацию:

1. Размер символов,
2. Цвет фона,
3. Цвет текста,
4. Минимальная высота символов,
4. Используемые символы.
5. Интервал отрисовки.

Запишем всё в объект:

```javascript
const params = {
  size: 10,
  bgColor: "rgba(0, 0, 0, 0.05)",
  textColor: "#0F0",
  charsHeight: [50, 10000],
  interval: 70,
  chars: "0123456789ABCDEF".split("")
};
```

Обсудим некоторые переменные.

Можно заметить, что фон имеет низкое значение альфа-канала, другими словами, он очень прозрачный. Так как после каждого кадра мы будем отрисовывать фон заново, это позволит создать эффект "угасающего" текста. Такой прозрачный фон закрасит его не сразу, а сделает исчезновение постепеннным.

Параметр `charsHeight` необходим для контроля длины цепочки символов. В массиве два значения: минимальное и максимальное.

Символы, которые будут отрисовываться в анимации будут браться случайным образом из массива, получаемого из разбитой строки. Позже мы значительно улучшим подход в этом направлении.

---

## Отрисовка

Разобьём ширину экрана на множество "треков", по котором и будут спускаться цепочки символов. С этой целью создадим массив из нулей, размером с ширину, разбитую на ровные части для ширины каждого символа:

```javascript
const columns = new Array(Math.floor(width / params.size) + 1).fill(0);
```

Далее, позаботимся о выборе случайного символа. В параметрах у нас есть массив с символами, поэтому нам нужно просто получить один из элементов случайным образом.

Для этого напишем функцию, получающую массив на вход. Генерируя число от 0 до длины массива, используем его как индекс и получаем случайный символ:

```javascript
const randomArrElement = (arr) => (
  arr[Math.floor(Math.random() * arr.length)]
);
```

Теперь, можно приступать к написанию функции рендеринга анимации.
Распишем действия поэтапно:

1. Заполним фон всего полота,
2. Переберём каждый элемент из массива треков -> значение и индекс, которые будут играть роль координат на полотне.
3. Отрисовываем случайный символ по координатам: (индекс * размер, значение),
4. Проверяем значение символа, больше ли оно высоты экрана ИЛИ случайного значения высоты полосы символов:
    - да: значение сбрасывается до нуля,
    - нет: спускаем символ вниз, прибавляя размер одного символа.

Реализуем наш алгоритм действий:

```javascript
function render({ chars, size, bgColor, textColor, charsHeight }) {
  context.fillStyle = bgColor;
  context.fillRect(0, 0, width, height);
  context.fillStyle = textColor;
  columns.forEach((value, index) => {
    // value -> y-coordinate
    context.fillText(randomArrElement(chars), index * size, value);
    columns[index] =
      value >= height ||
        value > charsHeight[0] + charsHeight[1] * Math.random()
          ? 0
          : value + size;
  });
}
```
Необходимые параметры фукнция получит из дестуктуризации объекта. Массив с треками и размеры экрана находятся в области видимости функции. Так как массив мутируется, мы используем `forEach()`. 

Теперь необходимо задать отрисовку с интервалом, чтобы запустить анимацию. Воспользуемся фукнцией `setInterval`, передав ей функцию отрисовки, указав интервал, заданный внутри объекта с параметрами и сами параметры для передачи в функцию отрисовки.

Анимация готова!

---

## Расширяем набор символов

То, как мы работаем с символами, даёт нам не так многоо контроля, как кажется. Да, мы можем выбирать символы собственноручно, однако, имеется ещё один подход с использованием статического метода конструктора строк `String.fromCharCode()`, возвращающий строку из последовательности кодировки UTF-16.

Например:

```javascript
console.log(String.fromCharCode(189, 43, 190, 61));
// вывод: "½+¾="
```

Снизу представлены интервалы, из которых мы можем генерировать необходимые нам символы UTF-8, поддерживаемых HTML5:

| Character  codes                   |	Decimal   |
|------------------------------------|------------|
| C0 Controls and Basic Latin        | 0-127	    |
| C1 Controls and Latin-1 Supplement | 128-255	  |
| Latin Extended-A	                 | 256-383	  |
| Latin Extended-B	                 | 384-591    |
| Spacing Modifiers                  | 688-767	  |
| Diacritical Marks                  | 768-879	  |
| Greek and Coptic                   | 880-1023   |
| Cyrillic Basic	                   | 1024-1279  |
| Cyrillic Supplement                | 1280-1327  |	
| General Punctuation                | 8192-8303  |
| Currency Symbols                   | 8352-8399  |
| Letterlike Symbols	               | 8448-8527  |
| Arrows	8592-8703	                 | 2190-21FF  |
| Mathematical Operators	           | 8704-8959  |	
| Box Drawings	                     | 9472-9599  |
| Block Elements	                   | 9600-9631  |	
| Geometric Shapes	                 | 9632-9727  |	
| Miscellaneous Symbols              | 9728-9983  |	
| Dingbats	                         | 9984-10175 |

Таким образом, мы можем генерировать случайные целые числа и таким образом получать случайные строки с помощью данного метода:

```javascript
function randomChar(min, max) {
  const code = Math.floor(Math.random() * (max - min)) + min;
  return String.fromCharCode(code);
} 
```

Сначала мы генерируем случайное целое число из интервала **[min, max]**, а после возвращаем стоку из кодировки. Используя этот способ, мы можем отредактировать нашу функцию отрисовки, заменив `randomArrElement()` на `randomChar()`.

---

## Больше контроля

К сожалению или к счастью, всё ещё можно столкнуться с неудобствами в контроле отрисовываемых символов. Напримем, `charCode` для латинских букв находится в интервале [ 65, 90 ], а цифры в интервале [ 48, 57 ]. Если мы захотим отрисовывать именно латинские буквы и цифры, то у нас пока нет такой возможности.

Чтобы решить проблему, нужно переписать генерацию случайных чисел для работы не с одним интервалом, а с несколькими.

Опишем алгоритм. На вход получаем двумерный массив, в котором каждый массив представляет из себя интервал из минимального и максимального значений:

1. Сложим все мощности интервалов (количество возможных значений:
    
    Например, [1, 4]: 1, 2, 3, 4 (4 значения)    
    ```[ [1, 5], [10, 12] ] -> 5 + 3 -> 8```
2. Генерируем случайное целое число из интервала [0, сумма мощностей].
3. Последовательно для каждого интервала проверяем, больше ли случайное число максимального значения этого интервала.
    - Нет: число принадлежит этому интервалу, возвращаем ответ, прибавляя минимальное значение интервала к случайному числу.
    - Да: проверяемый интервал не подходит, вычитаем можность интервала и проверяем следующий.

Другими словами, мы "склеиваем" интервалы в один, генерируем случайное число и ищем, к какой области оно относится.

Реализация может выглядеть так:

```javascript
function randomFromRanges() {
  let total = 0;
  for (const [ a, b ] of arguments) {
    // adding the ranges' size
    total += b - a + 1;
  }
  
  let randIntInclusive = Math.floor(Math.random() * total);
  
  for (const [ a, b ] of arguments) {
    return (randIntInclusive < b - a + 1)
      ? a + randIntInclusive
      : randIntInclusive -= b - a + 1;
  }
}
```

Напишем небольшую фукнцию для генерации символа:

```javascript
const randUnicodeChar = (ranges) => (
  String.fromCharCode(
    randomFromRanges(...ranges)
  )
);
```

Теперь в параметрах мы можем использовать диапазоны генерируемых символов следующим образом:

```javascript
chars: [
    [ 48, 57 ],     // digits
    [ 65, 90 ],     // capital letters
    [ 8704, 8959 ]  // math symbols
  ]
```

Итого, функция отрисовки примет следующий окончательный вид:

```javascript
function render({ chars, size, bgColor, textColor, charsHeight }) {
  context.fillStyle = bgColor;
  context.fillRect(0, 0, width, height);
  context.fillStyle = textColor;
  columns.forEach((value, index) => {
    // value -> y-coordinate
    context.fillText(randUnicodeChar(chars), index * size, value);
    columns[index] =
      value >= height ||
        value > charsHeight[0] + charsHeight[1] * Math.random()
          ? 0
          : value + size;
  });
}
```
